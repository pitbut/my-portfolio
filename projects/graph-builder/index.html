<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìä –ü–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª—å –≥—Ä–∞—Ñ–∏–∫–æ–≤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
            background: white;
            margin: 10px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        /* –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å */
        .left-panel {
            width: 350px;
            background: #f5f5f5;
            border-right: 2px solid #ddd;
            overflow-y: auto;
            padding: 15px;
        }
        
        .section {
            background: white;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .section h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }
        
        .form-group {
            margin: 10px 0;
        }
        
        .form-group label {
            display: block;
            font-size: 13px;
            color: #555;
            margin-bottom: 5px;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin: 5px 0;
            transition: all 0.3s;
        }
        
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover { background: #5568d3; }
        
        .btn-success { background: #4CAF50; color: white; }
        .btn-success:hover { background: #45a049; }
        
        .btn-warning { background: #FF9800; color: white; }
        .btn-warning:hover { background: #f57c00; }
        
        .btn-danger { background: #f44336; color: white; }
        .btn-danger:hover { background: #da190b; }
        
        .btn-purple { background: #9C27B0; color: white; }
        .btn-purple:hover { background: #7B1FA2; }
        
        .btn-blue { background: #2196F3; color: white; }
        .btn-blue:hover { background: #0b7dda; }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .checkbox-group input {
            width: auto;
            margin-right: 8px;
        }
        
        .radio-group {
            margin: 5px 0;
        }
        
        .radio-group label {
            display: block;
            padding: 5px;
            cursor: pointer;
        }
        
        .radio-group input {
            margin-right: 8px;
        }
        
        .curve-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 5px;
        }
        
        .curve-item {
            padding: 8px;
            margin: 3px 0;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .curve-item:hover {
            background: #f0f0f0;
        }
        
        .curve-item.active {
            background: #667eea;
            color: white;
        }
        
        /* –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å */
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }
        
        .canvas-container {
            flex: 1;
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            position: relative;
            margin-bottom: 15px;
        }
        
        #graphCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        /* –¢–∞–±–ª–∏—Ü–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç */
        .table-container {
            height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-radius: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: #667eea;
            color: white;
            padding: 10px;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        td {
            padding: 8px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        
        tr:hover {
            background: #f5f5f5;
        }
        
        .color-btn {
            width: 30px;
            height: 30px;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
            display: inline-block;
        }
        
        .color-btn.active {
            border: 3px solid #000;
        }
        
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å -->
        <div class="left-panel">
            <!-- –ù–∞—á–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ -->
            <div class="section">
                <h3>‚öôÔ∏è –ù–∞—á–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
                
                <div class="form-group">
                    <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–∏–≤—ã—Ö:</label>
                    <input type="number" id="numCurves" value="3" min="1" max="10">
                </div>
                
                <button class="btn btn-primary" onclick="createCurves()">–°–æ–∑–¥–∞—Ç—å –∫—Ä–∏–≤—ã–µ</button>
                
                <div class="form-group">
                    <label>–ü–æ–¥–ø–∏—Å—å –æ—Å–∏ X:</label>
                    <input type="text" id="labelX" value="X">
                </div>
                
                <div class="form-group">
                    <label>–ü–æ–¥–ø–∏—Å—å –æ—Å–∏ Y:</label>
                    <input type="text" id="labelY" value="Y">
                </div>
                
                <div class="form-group">
                    <label>–ú–∞–∫—Å–∏–º—É–º X:</label>
                    <input type="number" id="maxX" value="1000" min="10">
                </div>
                
                <div class="form-group">
                    <label>–ú–∞–∫—Å–∏–º—É–º Y:</label>
                    <input type="number" id="maxY" value="10" min="1">
                </div>
                
                <div class="form-group">
                    <label>–®–∞–≥ —Å–µ—Ç–∫–∏ X:</label>
                    <input type="number" id="gridStepX" value="100" min="1">
                </div>
                
                <div class="form-group">
                    <label>–®–∞–≥ —Å–µ—Ç–∫–∏ Y:</label>
                    <input type="number" id="gridStepY" value="1" min="0.1" step="0.1">
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showGrid" checked>
                    <label for="showGrid">–ü–æ–∫–∞–∑–∞—Ç—å —Å–µ—Ç–∫—É</label>
                </div>
                
                <button class="btn btn-success" onclick="applySettings()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</button>
            </div>
            
            <!-- –°–ø–∏—Å–æ–∫ –∫—Ä–∏–≤—ã—Ö -->
            <div class="section">
                <h3>üìà –ö—Ä–∏–≤—ã–µ</h3>
                <div class="curve-list" id="curveList"></div>
            </div>
            
            <!-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–µ–∫—É—â–µ–π –∫—Ä–∏–≤–æ–π -->
            <div class="section">
                <h3>üé® –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫—Ä–∏–≤–æ–π</h3>
                
                <div class="form-group">
                    <label>–ù–∞–∑–≤–∞–Ω–∏–µ:</label>
                    <input type="text" id="curveName" placeholder="–ö—Ä–∏–≤–∞—è 1">
                </div>
                
                <div class="form-group">
                    <label>–¶–≤–µ—Ç –ª–∏–Ω–∏–∏:</label>
                    <div id="colorPicker"></div>
                </div>
                
                <div class="form-group">
                    <label>–°—Ç–∏–ª—å –ª–∏–Ω–∏–∏:</label>
                    <select id="lineStyle">
                        <option value="solid">–°–ø–ª–æ—à–Ω–∞—è</option>
                        <option value="dashed">–®—Ç—Ä–∏—Ö–æ–≤–∞—è</option>
                        <option value="dotted">–¢–æ—á–µ—á–Ω–∞—è</option>
                        <option value="dashdot">–®—Ç—Ä–∏—Ö–ø—É–Ω–∫—Ç–∏—Ä–Ω–∞—è</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>–§–æ—Ä–º–∞ —Ç–æ—á–µ–∫:</label>
                    <select id="markerShape">
                        <option value="circle">–ö—Ä—É–≥</option>
                        <option value="square">–ö–≤–∞–¥—Ä–∞—Ç</option>
                        <option value="triangle">–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫</option>
                        <option value="diamond">–†–æ–º–±</option>
                        <option value="star">–ó–≤–µ–∑–¥–∞</option>
                        <option value="cross">–ö—Ä–µ—Å—Ç</option>
                    </select>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showPoints" checked>
                    <label for="showPoints">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ—á–∫–∏</label>
                </div>
                
                <button class="btn btn-primary" onclick="applyCurveSettings()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫ –∫—Ä–∏–≤–æ–π</button>
            </div>
            
            <!-- –†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã -->
            <div class="section">
                <h3>üñ±Ô∏è –†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã</h3>
                
                <div class="radio-group">
                    <label>
                        <input type="radio" name="mode" value="add" checked>
                        –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É
                    </label>
                    <label>
                        <input type="radio" name="mode" value="delete">
                        –£–¥–∞–ª–∏—Ç—å —Ç–æ—á–∫—É
                    </label>
                    <label>
                        <input type="radio" name="mode" value="move">
                        –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å —Ç–æ—á–∫—É
                    </label>
                </div>
                
                <button class="btn btn-danger" onclick="clearCurrentCurve()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –∫—Ä–∏–≤—É—é</button>
                <button class="btn btn-warning" onclick="smoothCurve()">üìà –°–≥–ª–∞–¥–∏—Ç—å –∫—Ä–∏–≤—É—é</button>
            </div>
            
            <!-- –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø–æ —Ñ–æ—Ä–º—É–ª–µ -->
            <div class="section">
                <h3>üî¢ –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø–æ —Ñ–æ—Ä–º—É–ª–µ</h3>
                
                <div class="form-group">
                    <label>–§–æ—Ä–º—É–ª–∞ (y=):</label>
                    <input type="text" id="formula" value="Math.sin(x/100)*5 + 5" placeholder="Math.sin(x)">
                </div>
                
                <div class="form-group">
                    <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫:</label>
                    <input type="number" id="numPoints" value="50" min="2" max="1000">
                </div>
                
                <button class="btn btn-purple" onclick="buildFromFormula()">–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø–æ —Ñ–æ—Ä–º—É–ª–µ</button>
                
                <small style="display: block; margin-top: 10px; color: #666;">
                    –ü—Ä–∏–º–µ—Ä—ã: Math.sin(x), x*x, Math.sqrt(x), Math.exp(x/100)
                </small>
            </div>
            
            <!-- –≠–∫—Å–ø–æ—Ä—Ç -->
            <div class="section">
                <h3>üíæ –≠–∫—Å–ø–æ—Ä—Ç</h3>
                
                <button class="btn btn-success" onclick="saveAsPNG()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG</button>
                <button class="btn btn-success" onclick="saveAsSVG()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å SVG</button>
                <button class="btn btn-blue" onclick="printGraph()">üñ®Ô∏è –ü–µ—á–∞—Ç—å</button>
            </div>
        </div>
        
        <!-- –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å -->
        <div class="right-panel">
            <h2 style="color: #667eea; margin-bottom: 15px;">üìä –ì—Ä–∞—Ñ–∏–∫</h2>
            
            <!-- –ì—Ä–∞—Ñ–∏–∫ -->
            <div class="canvas-container">
                <canvas id="graphCanvas"></canvas>
            </div>
            
            <!-- –¢–∞–±–ª–∏—Ü–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç -->
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>‚Ññ</th>
                            <th>X</th>
                            <th>Y</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <tr><td colspan="3">–í—ã–±–µ—Ä–∏—Ç–µ –∫—Ä–∏–≤—É—é</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let canvas, ctx;
        let curves = [];
        let currentCurveIndex = null;
        let mode = 'add';
        let settings = {
            labelX: 'X',
            labelY: 'Y',
            maxX: 1000,
            maxY: 10,
            gridStepX: 100,
            gridStepY: 1,
            showGrid: true
        };
        let draggingPoint = null;
        let hoveredPoint = null;
        
        const COLORS = ['#2196F3', '#FF5722', '#4CAF50', '#FFC107', '#9C27B0', '#00BCD4', '#FF9800', '#E91E63'];
        const MARGIN = 60;
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        window.onload = function() {
            canvas = document.getElementById('graphCanvas');
            ctx = canvas.getContext('2d');
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä canvas
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // –°–æ–±—ã—Ç–∏—è –º—ã—à–∏
            canvas.addEventListener('click', onCanvasClick);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp);
            
            // –†–µ–∂–∏–º—ã
            document.querySelectorAll('input[name="mode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    mode = e.target.value;
                    updateCursor();
                });
            });
            
            // –¶–≤–µ—Ç–∞
            createColorPicker();
            
            // –°–æ–∑–¥–∞—ë–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∫—Ä–∏–≤—ã–µ
            createCurves();
        };
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth - 4;
            canvas.height = container.clientHeight - 4;
            drawGraph();
        }
        
        function createColorPicker() {
            const picker = document.getElementById('colorPicker');
            COLORS.forEach((color, i) => {
                const btn = document.createElement('div');
                btn.className = 'color-btn';
                btn.style.backgroundColor = color;
                btn.onclick = () => selectColor(i);
                picker.appendChild(btn);
            });
        }
        
        function selectColor(index) {
            document.querySelectorAll('.color-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });
        }
        
        function createCurves() {
            const num = parseInt(document.getElementById('numCurves').value);
            curves = [];
            
            for (let i = 0; i < num; i++) {
                curves.push({
                    name: `–ö—Ä–∏–≤–∞—è ${i + 1}`,
                    points: [],
                    color: COLORS[i % COLORS.length],
                    lineStyle: 'solid',
                    markerShape: 'circle',
                    showPoints: true
                });
            }
            
            currentCurveIndex = 0;
            updateCurveList();
            updateCurveSettings();
            drawGraph();
        }
        
        function updateCurveList() {
            const list = document.getElementById('curveList');
            list.innerHTML = '';
            
            curves.forEach((curve, i) => {
                const item = document.createElement('div');
                item.className = 'curve-item' + (i === currentCurveIndex ? ' active' : '');
                item.innerHTML = `
                    <span style="display: inline-block; width: 15px; height: 15px; background: ${curve.color}; border-radius: 3px; margin-right: 8px;"></span>
                    ${curve.name} (${curve.points.length} —Ç–æ—á–µ–∫)
                `;
                item.onclick = () => selectCurve(i);
                list.appendChild(item);
            });
        }
        
        function selectCurve(index) {
            currentCurveIndex = index;
            updateCurveList();
            updateCurveSettings();
            updateTable();
        }
        
        function updateCurveSettings() {
            if (currentCurveIndex === null) return;
            
            const curve = curves[currentCurveIndex];
            document.getElementById('curveName').value = curve.name;
            document.getElementById('lineStyle').value = curve.lineStyle;
            document.getElementById('markerShape').value = curve.markerShape;
            document.getElementById('showPoints').checked = curve.showPoints;
            
            // –í—ã–±—Ä–∞—Ç—å —Ü–≤–µ—Ç
            const colorIndex = COLORS.indexOf(curve.color);
            selectColor(colorIndex >= 0 ? colorIndex : 0);
        }
        
        function applyCurveSettings() {
            if (currentCurveIndex === null) return;
            
            const curve = curves[currentCurveIndex];
            curve.name = document.getElementById('curveName').value;
            curve.lineStyle = document.getElementById('lineStyle').value;
            curve.markerShape = document.getElementById('markerShape').value;
            curve.showPoints = document.getElementById('showPoints').checked;
            
            // –ü–æ–ª—É—á–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ü–≤–µ—Ç
            const activeColor = document.querySelector('.color-btn.active');
            if (activeColor) {
                curve.color = activeColor.style.backgroundColor;
            }
            
            updateCurveList();
            drawGraph();
        }
        
        function applySettings() {
            settings.labelX = document.getElementById('labelX').value;
            settings.labelY = document.getElementById('labelY').value;
            settings.maxX = parseFloat(document.getElementById('maxX').value);
            settings.maxY = parseFloat(document.getElementById('maxY').value);
            settings.gridStepX = parseFloat(document.getElementById('gridStepX').value);
            settings.gridStepY = parseFloat(document.getElementById('gridStepY').value);
            settings.showGrid = document.getElementById('showGrid').checked;
            
            drawGraph();
        }
        
        function drawGraph() {
            if (!ctx) return;
            
            // –û—á–∏—Å—Ç–∫–∞
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –§–æ–Ω
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // –°–µ—Ç–∫–∞
            if (settings.showGrid) {
                drawGrid();
            }
            
            // –û—Å–∏
            drawAxes();
            
            // –ö—Ä–∏–≤—ã–µ
            curves.forEach(curve => drawCurve(curve));
            
            // –ü–æ–¥—Å–≤–µ—á–µ–Ω–Ω–∞—è —Ç–æ—á–∫–∞
            if (hoveredPoint) {
                drawHighlight(hoveredPoint.x, hoveredPoint.y);
            }
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            
            const graphWidth = canvas.width - 2 * MARGIN;
            const graphHeight = canvas.height - 2 * MARGIN;
            
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
            for (let x = 0; x <= settings.maxX; x += settings.gridStepX) {
                const px = MARGIN + (x / settings.maxX) * graphWidth;
                ctx.beginPath();
                ctx.moveTo(px, MARGIN);
                ctx.lineTo(px, canvas.height - MARGIN);
                ctx.stroke();
            }
            
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
            for (let y = 0; y <= settings.maxY; y += settings.gridStepY) {
                const py = canvas.height - MARGIN - (y / settings.maxY) * graphHeight;
                ctx.beginPath();
                ctx.moveTo(MARGIN, py);
                ctx.lineTo(canvas.width - MARGIN, py);
                ctx.stroke();
            }
        }
        
        function drawAxes() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.setLineDash([]);
            
            const graphWidth = canvas.width - 2 * MARGIN;
            const graphHeight = canvas.height - 2 * MARGIN;
            
            // –û—Å—å X
            ctx.beginPath();
            ctx.moveTo(MARGIN, canvas.height - MARGIN);
            ctx.lineTo(canvas.width - MARGIN, canvas.height - MARGIN);
            ctx.stroke();
            
            // –°—Ç—Ä–µ–ª–∫–∞ X
            ctx.beginPath();
            ctx.moveTo(canvas.width - MARGIN, canvas.height - MARGIN);
            ctx.lineTo(canvas.width - MARGIN - 10, canvas.height - MARGIN - 5);
            ctx.lineTo(canvas.width - MARGIN - 10, canvas.height - MARGIN + 5);
            ctx.fill();
            
            // –ü–æ–¥–ø–∏—Å—å X
            ctx.textAlign = 'center';
            ctx.fillText(settings.labelX, canvas.width - MARGIN / 2, canvas.height - MARGIN + 5);
            
            // –û—Å—å Y
            ctx.beginPath();
            ctx.moveTo(MARGIN, canvas.height - MARGIN);
            ctx.lineTo(MARGIN, MARGIN);
            ctx.stroke();
            
            // –°—Ç—Ä–µ–ª–∫–∞ Y
            ctx.beginPath();
            ctx.moveTo(MARGIN, MARGIN);
            ctx.lineTo(MARGIN - 5, MARGIN + 10);
            ctx.lineTo(MARGIN + 5, MARGIN + 10);
            ctx.fill();
            
            // –ü–æ–¥–ø–∏—Å—å Y
            ctx.save();
            ctx.translate(MARGIN - 40, MARGIN + 20);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(settings.labelY, 0, 0);
            ctx.restore();
            
            // –ú–µ—Ç–∫–∏ –Ω–∞ –æ—Å—è—Ö
            ctx.font = '11px Arial';
            ctx.fillStyle = '#666';
            
            // –ú–µ—Ç–∫–∏ X
            for (let x = 0; x <= settings.maxX; x += settings.gridStepX) {
                const px = MARGIN + (x / settings.maxX) * graphWidth;
                ctx.textAlign = 'center';
                ctx.fillText(x, px, canvas.height - MARGIN + 20);
            }
            
            // –ú–µ—Ç–∫–∏ Y
            for (let y = 0; y <= settings.maxY; y += settings.gridStepY) {
                const py = canvas.height - MARGIN - (y / settings.maxY) * graphHeight;
                ctx.textAlign = 'right';
                ctx.fillText(y.toFixed(1), MARGIN - 10, py + 4);
            }
        }
        
        function drawCurve(curve) {
            if (curve.points.length === 0) return;
            
            const graphWidth = canvas.width - 2 * MARGIN;
            const graphHeight = canvas.height - 2 * MARGIN;
            
            // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Ç–æ—á–µ–∫ –ø–æ X
            const sortedPoints = [...curve.points].sort((a, b) => a.x - a.x);
            
            // –õ–∏–Ω–∏—è
            ctx.strokeStyle = curve.color;
            ctx.lineWidth = 2;
            
            // –°—Ç–∏–ª—å –ª–∏–Ω–∏–∏
            switch (curve.lineStyle) {
                case 'dashed':
                    ctx.setLineDash([10, 5]);
                    break;
                case 'dotted':
                    ctx.setLineDash([2, 3]);
                    break;
                case 'dashdot':
                    ctx.setLineDash([10, 5, 2, 5]);
                    break;
                default:
                    ctx.setLineDash([]);
            }
            
            ctx.beginPath();
            sortedPoints.forEach((point, i) => {
                const px = MARGIN + (point.x / settings.maxX) * graphWidth;
                const py = canvas.height - MARGIN - (point.y / settings.maxY) * graphHeight;
                
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            });
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // –¢–æ—á–∫–∏
            if (curve.showPoints) {
                curve.points.forEach(point => {
                    const px = MARGIN + (point.x / settings.maxX) * graphWidth;
                    const py = canvas.height - MARGIN - (point.y / settings.maxY) * graphHeight;
                    drawMarker(px, py, curve.markerShape, curve.color);
                });
            }
        }
        
        function drawMarker(x, y, shape, color) {
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            
            const size = 6;
            
            switch (shape) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'square':
                    ctx.fillRect(x - size, y - size, size * 2, size * 2);
                    break;
                    
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(x, y - size);
                    ctx.lineTo(x + size, y + size);
                    ctx.lineTo(x - size, y + size);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'diamond':
                    ctx.beginPath();
                    ctx.moveTo(x, y - size);
                    ctx.lineTo(x + size, y);
                    ctx.lineTo(x, y + size);
                    ctx.lineTo(x - size, y);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'star':
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                        const radius = i % 2 === 0 ? size : size / 2;
                        const px = x + Math.cos(angle) * radius;
                        const py = y + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'cross':
                    ctx.beginPath();
                    ctx.moveTo(x - size, y);
                    ctx.lineTo(x + size, y);
                    ctx.moveTo(x, y - size);
                    ctx.lineTo(x, y + size);
                    ctx.stroke();
                    break;
            }
        }
        
        function drawHighlight(x, y) {
            const graphWidth = canvas.width - 2 * MARGIN;
            const graphHeight = canvas.height - 2 * MARGIN;
            const px = MARGIN + (x / settings.maxX) * graphWidth;
            const py = canvas.height - MARGIN - (y / settings.maxY) * graphHeight;
            
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(px, py, 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        function canvasToGraph(canvasX, canvasY) {
            const graphWidth = canvas.width - 2 * MARGIN;
            const graphHeight = canvas.height - 2 * MARGIN;
            
            const x = ((canvasX - MARGIN) / graphWidth) * settings.maxX;
            const y = ((canvas.height - MARGIN - canvasY) / graphHeight) * settings.maxY;
            
            return {
                x: Math.max(0, Math.min(settings.maxX, x)),
                y: Math.max(0, Math.min(settings.maxY, y))
            };
        }
        
        function findNearestPoint(x, y, threshold = 20) {
            if (currentCurveIndex === null) return null;
            
            const curve = curves[currentCurveIndex];
            const graphWidth = canvas.width - 2 * MARGIN;
            const graphHeight = canvas.height - 2 * MARGIN;
            
            let nearest = null;
            let minDist = threshold;
            
            curve.points.forEach((point, index) => {
                const px = MARGIN + (point.x / settings.maxX) * graphWidth;
                const py = canvas.height - MARGIN - (point.y / settings.maxY) * graphHeight;
                const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
                
                if (dist < minDist) {
                    minDist = dist;
                    nearest = { point, index };
                }
            });
            
            return nearest;
        }
        
        function onCanvasClick(e) {
            if (currentCurveIndex === null) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const graphPoint = canvasToGraph(x, y);
            
            if (mode === 'add') {
                curves[currentCurveIndex].points.push(graphPoint);
                updateCurveList();
                updateTable();
                drawGraph();
            } else if (mode === 'delete') {
                const nearest = findNearestPoint(x, y);
                if (nearest) {
                    curves[currentCurveIndex].points.splice(nearest.index, 1);
                    updateCurveList();
                    updateTable();
                    drawGraph();
                }
            }
        }
        
        function onMouseDown(e) {
            if (mode !== 'move' || currentCurveIndex === null) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            draggingPoint = findNearestPoint(x, y);
        }
        
        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (mode === 'move' && draggingPoint) {
                const graphPoint = canvasToGraph(x, y);
                curves[currentCurveIndex].points[draggingPoint.index] = graphPoint;
                updateTable();
                drawGraph();
            } else {
                // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Ç–æ—á–∫–∏ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
                const nearest = findNearestPoint(x, y);
                if (nearest) {
                    hoveredPoint = nearest.point;
                } else {
                    hoveredPoint = null;
                }
                drawGraph();
            }
        }
        
        function onMouseUp() {
            if (draggingPoint) {
                draggingPoint = null;
                updateTable();
            }
        }
        
        function updateCursor() {
            switch (mode) {
                case 'add':
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'delete':
                    canvas.style.cursor = 'not-allowed';
                    break;
                case 'move':
                    canvas.style.cursor = 'move';
                    break;
            }
        }
        
        function updateTable() {
            if (currentCurveIndex === null) {
                document.getElementById('tableBody').innerHTML = '<tr><td colspan="3">–í—ã–±–µ—Ä–∏—Ç–µ –∫—Ä–∏–≤—É—é</td></tr>';
                return;
            }
            
            const curve = curves[currentCurveIndex];
            const tbody = document.getElementById('tableBody');
            
            if (curve.points.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3">–ù–µ—Ç —Ç–æ—á–µ–∫</td></tr>';
                return;
            }
            
            tbody.innerHTML = curve.points
                .map((point, i) => `
                    <tr>
                        <td>${i + 1}</td>
                        <td>${point.x.toFixed(2)}</td>
                        <td>${point.y.toFixed(2)}</td>
                    </tr>
                `)
                .join('');
        }
        
        function clearCurrentCurve() {
            if (currentCurveIndex === null) return;
            
            if (confirm(`–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–æ—á–∫–∏ –∏–∑ –∫—Ä–∏–≤–æ–π "${curves[currentCurveIndex].name}"?`)) {
                curves[currentCurveIndex].points = [];
                updateCurveList();
                updateTable();
                drawGraph();
            }
        }
        
        function smoothCurve() {
            if (currentCurveIndex === null) return;
            
            const curve = curves[currentCurveIndex];
            if (curve.points.length < 3) {
                alert('–î–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è –Ω—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 3 —Ç–æ—á–∫–∏');
                return;
            }
            
            // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
            const sorted = [...curve.points].sort((a, b) => a.x - b.x);
            
            // –ö—É–±–∏—á–µ—Å–∫–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è)
            const smoothed = [];
            const steps = 100;
            
            for (let i = 0; i < sorted.length - 1; i++) {
                const p0 = sorted[Math.max(0, i - 1)];
                const p1 = sorted[i];
                const p2 = sorted[i + 1];
                const p3 = sorted[Math.min(sorted.length - 1, i + 2)];
                
                for (let t = 0; t < 1; t += 1 / steps) {
                    const x = catmullRom(p0.x, p1.x, p2.x, p3.x, t);
                    const y = catmullRom(p0.y, p1.y, p2.y, p3.y, t);
                    smoothed.push({ x, y });
                }
            }
            
            smoothed.push(sorted[sorted.length - 1]);
            
            curve.points = smoothed;
            updateCurveList();
            updateTable();
            drawGraph();
        }
        
        function catmullRom(p0, p1, p2, p3, t) {
            const v0 = (p2 - p0) * 0.5;
            const v1 = (p3 - p1) * 0.5;
            const t2 = t * t;
            const t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
        
        function buildFromFormula() {
            if (currentCurveIndex === null) return;
            
            const formula = document.getElementById('formula').value;
            const numPoints = parseInt(document.getElementById('numPoints').value);
            
            try {
                const points = [];
                const step = settings.maxX / (numPoints - 1);
                
                for (let i = 0; i < numPoints; i++) {
                    const x = i * step;
                    let y;
                    
                    try {
                        y = eval(formula.replace(/x/g, x));
                    } catch {
                        throw new Error('–û—à–∏–±–∫–∞ –≤ —Ñ–æ—Ä–º—É–ª–µ');
                    }
                    
                    if (isNaN(y) || !isFinite(y)) {
                        continue;
                    }
                    
                    y = Math.max(0, Math.min(settings.maxY, y));
                    points.push({ x, y });
                }
                
                if (points.length === 0) {
                    throw new Error('–§–æ—Ä–º—É–ª–∞ –Ω–µ –¥–∞–ª–∞ –≤–∞–ª–∏–¥–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤');
                }
                
                curves[currentCurveIndex].points = points;
                updateCurveList();
                updateTable();
                drawGraph();
                
                alert(`–ì—Ä–∞—Ñ–∏–∫ –ø–æ—Å—Ç—Ä–æ–µ–Ω!\n–°–æ–∑–¥–∞–Ω–æ ${points.length} —Ç–æ—á–µ–∫.\n–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ—á–∫–∏ –≤—Ä—É—á–Ω—É—é.`);
            } catch (error) {
                alert('–û—à–∏–±–∫–∞ –≤ —Ñ–æ—Ä–º—É–ª–µ:\n' + error.message + '\n\n–ü—Ä–∏–º–µ—Ä—ã –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Ñ–æ—Ä–º—É–ª:\nMath.sin(x/100)*5 + 5\nx*x/100\nMath.sqrt(x)');
            }
        }
        
        function saveAsPNG() {
            const link = document.createElement('a');
            link.download = '–≥—Ä–∞—Ñ–∏–∫.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        function saveAsSVG() {
            // SVG –≥–µ–Ω–µ—Ä–∞—Ü–∏—è (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è)
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}">`;
            svg += `<rect width="${canvas.width}" height="${canvas.height}" fill="white"/>`;
            
            // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–Ω–∞—è SVG –≥–µ–Ω–µ—Ä–∞—Ü–∏—è
            // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º canvas –≤ PNG –∏ –≤—Å—Ç—Ä–∞–∏–≤–∞–µ–º
            const dataURL = canvas.toDataURL('image/png');
            svg += `<image href="${dataURL}" width="${canvas.width}" height="${canvas.height}"/>`;
            svg += `</svg>`;
            
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.download = '–≥—Ä–∞—Ñ–∏–∫.svg';
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function printGraph() {
            const dataURL = canvas.toDataURL('image/png');
            const win = window.open('');
            win.document.write(`
                <html>
                <head><title>–ü–µ—á–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫–∞</title></head>
                <body style="margin:0; display:flex; justify-content:center; align-items:center; min-height:100vh;">
                    <img src="${dataURL}" style="max-width:100%; max-height:100vh;" onload="window.print(); window.close();">
                </body>
                </html>
            `);
        }
    </script>
</body>
</html>
